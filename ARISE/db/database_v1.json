{
    "behavior": {
        "description": [
            "The adversarial pedestrian suddenly crosses the road and suddenly stops in front of the ego vehicle.",
            "The pedestrain crosses the road .",
            "The adversarial pedestrian waits until the ego vehicle is within a certain distance, then walks diagonally across the road at a set speed and angle.",
            "The adversarial pedestrian waits and then crosses the road in a zigzag pattern, changing direction intermittently to simulate erratic pedestrian movement.",
            "The adversarial pedestrian starts walking towards the road when the ego vehicle is close, suddenly stops mid-way, and then resumes walking.",
            "The adversarial pedestrian starts walking randomly in short bursts, pausing intermittently, simulating unpredictable pedestrian behavior.",
            "The adversarial pedestrian gradually increases their walking speed as they approach the road, creating a dynamic challenge for the vehicle's perception systems.",
            "The adversarial pedestrian changes their walking direction erratically at random intervals, simulating distracted or unpredictable pedestrian behavior.",
            "The adversarial pedestrian loops in a small circle, providing a constant but predictable pattern that tests tracking algorithms.",
            "The adversarial pedestrian crosses the road .",
            "The adversarial motorcyclist is crossing the road but brakes abruptly.",
            "The adversarial cyclist s crossing the road but suddenly stops in the middle of the intersection",
            "The adversarial cyclist is crossing the road but brakes abruptly",
            "The adversarial motorcyclist is crossing the road suddenly stops in the middle of the intersection",
            "The adversarial cyclist crosses the road .",
            "The adversarial motorcyclist crosses the road .",
            "The adversarial cyclist crosses the road with pre-determined erratic speed changes at 1-second intervals, creating unpredictable movement patterns that challenge the ego vehicle's predictive algorithms.",
            "The adversarial cyclist crosses the road and suddenly stops mid-cross, then unexpectedly resumes crossing at a different speed, testing the ego vehicle's reaction to abrupt changes.",
            "The adversarial cyclist or motorcyclist moves in an irregular zigzag pattern across the road, making it difficult for the ego vehicle to predict their path.",
            "The adversarial cyclist or motorcyclist accelerates and decelerates intermittently while crossing, creating unpredictable speed variations.",
            "The adversarial car in the target lane suddenly merges into the ego vehicle's original lane.",
            "The adversarial vehicle abruptly stops after a lane change.",
            "The adversarial vehicle performs erratic weaving between lanes.",
            "The adversarial vehicle is strategically positioned to drive parallel in the right lane next to the ego vehicle with the same speed",
            "The adversarial vehicle initially follows the lane at a set speed and then suddenly brakes.",
            "The adversarial vehicle brakes suddenly and, after a brief pause, accelerates aggressively.",
            "The adversarial vehicle steers erratically, alternating sudden lane changes to the left and right.",
            "The adversarial vehicle changes its speed randomly, alternating between using the throttle for acceleration and brakes for slowing down.",
            "The adversarial vehicle performs a cycle of full braking followed by moderate speed resumption.",
            "The adversarial vehicle starts weaving between lanes as the ego vehicle approaches.",
            "The adversarial vehicle in the target lane suddenly slows down to match the speed of a slow-moving leading vehicle.",
            "The adversarial cyclist or motorcycle driver comes from the nearby opposite oncoming lane.",
            "The adversarial car comes from the nearby opposite oncoming lane.",
            "The adversarial car suddenly accelerates as it nears the ego vehicle.",
            "The adversarial car suddenly changes to ego's lanes as it nears the ego vehicle.",
            "The adversarial car suddenly breaks as it nears the ego vehicle.",
            "The adversarial car suddenly alternates between acceleration and deceleration as it nears the ego vehicle.",
            "The adversarial car unpredictably swerves within its lane as it nears the ego vehicle.",
            "The adversarial pedestrain, comes from the opposite direction, suddenly stop as it nears the ego vehicle.",
            "The adversarial pedestrain, comes from the opposite direction, gradually accelerates as they approach the ego vehicle.",
            "The adversarial vehicle crosses the intersection, accelerates unexpectedly, and suddenly stops as it approaches the ego's trajectory.",
            "The adversarial vehicle crosses the intersection and makes an abrupt right turn as it approaches the ego's trajectory.",
            "The adversarial vehicle crosses the intersection and makes an abrupt left turn as it approaches the ego's trajectory.",
            "The adversarial vehicle crosses the intersection, and abruptly braking as it approaches the ego's trajectory.",
            "The adversarial vehicle crosses the intersection, and abruptly accelerates as it approaches the ego's trajectory.",
            "The adversarial vehicle crosses the intersection, and aggressively cuts off the lane for ego vehicle.",
            "The adversarial vehicle crosses the intersection, and suddenly brakes when approaching the ego's trajectory.",
            "The adversarial vehicle approaches the intersection at normal speed and suddenly makes a last-second right turn.",
            "The adversarial vehicle approaches the intersection at normal speed, suddenly makes a calculated left turn and then stop.",
            "The adversarial vehicle approaches the intersection at normal speed, alternates its turning direction between left and right on successive approaches.",
            "The adversarial vehicle approaches the intersection normally but begins to veer erratically as it nears the ego vehicle.",
            "The adversarial vehicle approaches the intersection normally but begins to drives extremely slowly as it nears the ego vehicle.",
            "The adversarial vehicle alternates between high and low speeds in a predictable cycle as it approaches and crosses the intersection.",
            "The adversarial vehicle approaches the intersection normally but begins to make an abrupt reversal as it nears the ego vehicle.",
            "The adversarial vehicle approaches the intersection normally but suddenly accelerates and then abruptly decelerates",
            "The adversarial vehicle suddenly changes to the right lane when the ego approaches.",
            "The adversarial vehicle suddenly changes to the left lane when the ego approaches.",
            "The adversarial vehicle suddenly merges into the ego\u2019s lane."
        ],
        "snippet": [
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE) until (distance from self to EgoTrajectory) < globalParameters.OPT_STOP_DISTANCE\n    while True:\n        take SetWalkingSpeedAction(0)\n\nparam OPT_ADV_SPEED = Range(0, 5)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_STOP_DISTANCE = Range(0, 1)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n\nparam OPT_ADV_SPEED = Range(1, 5)  # Define the speed range for the adversarial pedestrain\nparam OPT_ADV_DISTANCE = Range(0, 15)  # Define the proximity threshold to trigger the crossing behavior",
            "behavior AdvBehavior():\n    direction = self.heading + globalParameters.OPT_ADV_DEGREE deg\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        take SetWalkingDirectionAction(direction)\n        take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(0, 5)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_ADV_DEGREE = Range(-90, 90)",
            "behavior AdvBehavior():\n    direction = self.heading + Range(-45, 45)  # Zigzag within a 45-degree variance left or right\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        alternate {\n            take SetWalkingDirectionAction(direction + 45)\n            wait 2 seconds\n            take SetWalkingDirectionAction(direction - 45)\n            wait 2 seconds\n        }\n        take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(1, 3)  # Slower speeds for more controlled zigzag motion\nparam OPT_ADV_DISTANCE = Range(10, 20)  # Longer wait distance\nparam OPT_ADV_DEGREE = Range(-45, 45)",
            "behavior AdvBehavior():\n    initialDirection = self.heading\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    do {\n        take SetWalkingDirectionAction(initialDirection)\n        take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n        wait 5 seconds\n        take SetWalkingSpeedAction(0)  # Stop suddenly\n        wait 3 seconds\n    } until True\n\nparam OPT_ADV_SPEED = Range(0, 5)\nparam OPT_ADV_DISTANCE = Range(0, 10)",
            "behavior AdvBehavior():\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        if globalParameters.OPT_DECIDE_TO_WALK < globalParameters.OPT_RANDOM_CHANCE:\n            take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n            wait globalParameters.OPT_WALK_DURATION\n        take SetWalkingSpeedAction(0)\n        wait globalParameters.OPT_PAUSE_DURATION\n\nparam OPT_ADV_SPEED = Range(0, 4)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_RANDOM_CHANCE = 0.5  # Probability threshold for deciding to walk\nparam OPT_DECIDE_TO_WALK = Range(0, 1)  # Randomly generated number to compare against OPT_RANDOM_CHANCE\nparam OPT_WALK_DURATION = Range(1, 3)  # Random duration of walking in seconds\nparam OPT_PAUSE_DURATION = Range(1, 3)  # Random duration of pausing in seconds\nparam OPT_ADV_DEGREE = Range(-90, 90)  # More variable walking directions",
            "behavior AdvBehavior():\n    direction = self.heading\n    currentSpeed = 0\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        currentSpeed = min(currentSpeed + 0.5, globalParameters.OPT_ADV_SPEED)  # Gradually increase speed\n        take SetWalkingSpeedAction(currentSpeed)\n        wait 1 second  # Increase speed every second\n\nparam OPT_ADV_SPEED = Range(1, 5)\nparam OPT_ADV_DISTANCE = Range(10, 20)",
            "behavior AdvBehavior():\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        # Direction change is randomized within a specified range and adjusted based on current heading\n        directionChange = globalParameters.OPT_DIRECTION_CHANGE  # Random direction change within +/- 90 degrees\n        direction = self.heading + directionChange\n        take SetWalkingDirectionAction(direction)\n        take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n        wait globalParameters.OPT_DIRECTION_CHANGE_DURATION  # Wait for a random duration before changing direction again\n\nparam OPT_ADV_SPEED = Range(0, 5)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_DIRECTION_CHANGE = Range(-90, 90)  # Random direction change degree\nparam OPT_DIRECTION_CHANGE_DURATION = Range(2, 5)  # Random duration for direction change",
            "behavior AdvBehavior():\n    while (distance to self) > globalParameters.OPT_ADV_DISTANCE:\n        wait\n    while True:\n        for angle in range(0, 360, 45):  # Loop in increments to make a circle\n            direction = self.heading + angle\n            take SetWalkingDirectionAction(direction)\n            take SetWalkingSpeedAction(globalParameters.OPT_ADV_SPEED)\n            wait 1 second\n\nparam OPT_ADV_SPEED = Range(1, 3)\nparam OPT_ADV_DISTANCE = Range(0, 10)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n\nparam OPT_ADV_SPEED = Range(1, 5)  # Define the speed range for the adversarial pedestrian\nparam OPT_ADV_DISTANCE = Range(0, 15)  # Define the proximity threshold to trigger the crossing behavior",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE) until (distance from self to EgoTrajectory) < globalParameters.OPT_BRAKE_DISTANCE\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_BRAKE_DISTANCE = Range(0, 1)\nparam OPT_BRAKE = Range(0, 1)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE) until (distance from self to EgoTrajectory) < globalParameters.OPT_STOP_DISTANCE\n    while True:\n        take SetSpeedAction(0)\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_STOP_DISTANCE = Range(0, 1)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE) until (distance from self to EgoTrajectory) < globalParameters.OPT_BRAKE_DISTANCE\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_BRAKE_DISTANCE = Range(0, 1)\nparam OPT_BRAKE = Range(0, 1)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE) until (distance from self to EgoTrajectory) < globalParameters.OPT_STOP_DISTANCE\n    while True:\n        take SetSpeedAction(0)\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(0, 15)\nparam OPT_STOP_DISTANCE = Range(0, 1)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n\nparam OPT_ADV_SPEED = Range(1, 10)  # Define the speed range for the adversarial cyclist\nparam OPT_ADV_DISTANCE = Range(0, 15)  # Define the proximity threshold to trigger the crossing behavior",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n\nparam OPT_ADV_SPEED = Range(1, 10)  # Define the speed range for the adversarial motorcyclist\nparam OPT_ADV_DISTANCE = Range(0, 15)  # Define the proximity threshold to trigger the crossing behavior",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n    while True:\n        # Set speed to a random value within the allowable range at each cycle\n        speedChange = globalParameters.OPT_SPEED_CHANGE  # Random speed adjustment\n        take SetSpeedAction(speedChange)\n        wait 1  # Wait for a fixed interval of 1 second before changing speed again\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(10, 20)\nparam OPT_SPEED_CHANGE = Range(0, 10)  # Allows random speed setting up to the maximum defined speed",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n    while True:\n        take SetSpeedAction(0)  # Stop suddenly\n        wait 2  # Stop for 2 seconds\n        take SetSpeedAction(globalParameters.OPT_RESUME_SPEED)  # Resume crossing at a different speed\n        wait 1  # Change speed after 1 second\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(10, 20)\nparam OPT_RESUME_SPEED = Range(0, 10)  # Potentially different speed for resuming",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n    while True:\n        take SetSteerAction(Range(-1, 1))  # Randomly change steering to left or right\n        wait 0.5  # Change direction every half second\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(10, 20)",
            "behavior AdvBehavior():\n    do CrossingBehavior(ego, globalParameters.OPT_ADV_SPEED, globalParameters.OPT_ADV_DISTANCE)\n    while True:\n        take SetThrottleAction(Range(0, 1))  # Random throttle adjustments\n        wait 1  # Adjust speed every second\n\nparam OPT_ADV_SPEED = Range(0, 10)\nparam OPT_ADV_DISTANCE = Range(10, 20)",
            "behavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (\n        distance to self < globalParameters.OPT_ADV_DISTANCE and\n        len(network.laneSectionAt(self).adjacentLanes) != 0\n    )\n    # Identify the lane to switch into\n    weaveLaneSec = network.laneSectionAt(self).adjacentLanes[0]\n    # Execute the lane change\n    do LaneChangeBehavior(laneSectionToSwitch=weaveLaneSec, target_speed=globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)",
            "behavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (\n        distance to self < globalParameters.OPT_ADV_DISTANCE\n    )\n    # Abruptly stop after a lane change\n    targetLaneSec = network.laneSectionAt(self).adjacentLanes[0]\n    do LaneChangeBehavior(laneSectionToSwitch=targetLaneSec, target_speed=globalParameters.OPT_ADV_SPEED)\n    wait 1  # wait for a second before stopping\n    do SetSpeedAction(0)  # Stop the vehicle\n\nparam OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)",
            "behavior AdvBehavior():\n    while True:\n        do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (\n            distance to self < globalParameters.OPT_ADV_DISTANCE\n        )\n        for _ in range(2):  # Perform two quick lane changes\n            if len(network.laneSectionAt(self).adjacentLanes) > 0:\n                targetLaneSec = network.laneSectionAt(self).adjacentLanes[0]\n                do LaneChangeBehavior(laneSectionToSwitch=targetLaneSec, target_speed=globalParameters.OPT_ADV_SPEED)\n            wait 1  # Wait for a second before changing the lane again\n\nparam OPT_ADV_SPEED = Range(5, 15)\nparam OPT_ADV_DISTANCE = Range(0, 20)",
            "behavior AdvBehavior():\n    while True:\n        take SetVelocityAction(*ego.velocity)",
            "param OPT_ADV_SPEED = Range(5, 10)  # Adversarial vehicle's cruising speed\nparam OPT_ADV_DISTANCE = Range(0, 20)  # Distance threshold to initiate braking\nparam OPT_BRAKE = Range(0, 1)  # Braking intensity, where 1 represents full braking\n\nbehavior AdvBehavior():\n    # Follow the lane at the defined speed until close enough to the ego vehicle\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    # Once within the distance threshold, execute a sudden brake to test the ego vehicle's response capabilities\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)",
            "param OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)\nparam OPT_BRAKE = Range(0, 1)\nparam OPT_PAUSE_DURATION = Range(1, 3)\nparam OPT_THROTTLE = Range(0.5, 1)  # Throttle intensity for acceleration\n\nbehavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)\n        wait globalParameters.OPT_PAUSE_DURATION\n        take SetThrottleAction(globalParameters.OPT_THROTTLE)",
            "param OPT_ADV_SPEED = Range(5, 10)\nparam OPT_LANE_SWAP_FREQUENCY = Range(2, 5)  # Frequency of lane swaps\nparam OPT_STEER = Range(-1, 1)  # Steering range for lane changes\n\nbehavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED)\n    while True:\n        take SetSteerAction(Range(-1, 0))  # Steering left\n        wait 1\n        take SetSteerAction(Range(0, 1))  # Steering right\n        wait globalParameters.OPT_LANE_SWAP_FREQUENCY",
            "param OPT_MAX_THROTTLE = Range(0.5, 1)\n\nbehavior AdvBehavior():\n    while True:\n        newThrottle = Range(0, globalParameters.OPT_MAX_THROTTLE)\n        take SetThrottleAction(newThrottle)\n        wait Range(1, 3)  # Time between throttle changes\n        take SetBrakeAction(Range(0, 0.5))  # Random braking intensity\n        wait 2  # Wait for 2 seconds before changing throttle again",
            "param OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)\nparam OPT_BRAKE = Range(0, 1)\n\nbehavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetBrakeAction(1)  # Full stop\n        wait 2  # Hold the brake for 2 seconds\n        take SetThrottleAction(0.5)  # Resume with moderate speed",
            "param OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)\n\nbehavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        weaveLaneSec = network.laneSectionAt(self).adjacentLanes[0]\n        do LaneChangeBehavior(laneSectionToSwitch=weaveLaneSec, target_speed=globalParameters.OPT_ADV_SPEED)",
            "param OPT_ADV_SPEED = Range(5, 10)\nparam OPT_ADV_DISTANCE = Range(0, 20)\n\nbehavior AdvBehavior():\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetVelocityAction(*LeadingAgent.velocity)",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(0, 10)  # This parameter controls the motorcyclist's speed, influencing the urgency and danger of the maneuver.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(0, 20)  # This parameter controls the motorcyclist's speed, influencing the urgency and danger of the maneuver.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial car waits until it is within 60 meters of the ego vehicle.\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetThrottleAction(globalParameters.OPT_ADV_THROTTLE)  # Aggressively adjusts its speed to close the gap.\n\nparam OPT_ADV_SPEED = Range(0, 10)  # Controls the initial speed of the adversarial car.\nparam OPT_ADV_DISTANCE = Range(0, 20)  # Specifies the distance at which the car begins its aggressive maneuver.\nparam OPT_ADV_THROTTLE = Range(0.5, 1)  # Determines the intensity of the acceleration.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle maintains its course until it closes in on a specified proximity.\n    do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    # Once within a certain distance, the adversarial vehicle executes a lane change.\n    do LaneChangeBehavior(laneSectionToSwitch=network.laneSectionAt(ego), target_speed=globalParameters.OPT_ADV_SPEED)\n\nparam OPT_ADV_SPEED = Range(0, 20)  # Controls the speed of the adversarial vehicle.\nparam OPT_ADV_DISTANCE = Range(10, 30)  # The distance at which the adversarial vehicle starts its lane change maneuver.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial car waits until it is within 60 meters of the ego vehicle.\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetBrakeAction(globalParameters.OPT_ADV_BREAK)  # Aggressively adjusts its speed to close the gap.\n\nparam OPT_ADV_SPEED = Range(0, 20)  # Controls the initial speed of the adversarial car.\nparam OPT_ADV_DISTANCE = Range(0, 20)  # Specifies the distance at which the car begins its aggressive maneuver.\nparam OPT_ADV_BREAK = Range(0.5, 1)  # Determines the intensity of the break.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial car waits until it is within 60 meters of the ego vehicle.\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetThrottleAction(globalParameters.OPT_ADV_THROTTLE)  # Aggressively adjusts its acceleration to close the gap.\n        wait 1\n        take SetBrakeAction(globalParameters.OPT_ADV_BREAK)  # Aggressively adjusts its break to close the gap.\n        wait 1\n\nparam OPT_ADV_SPEED = Range(0, 20)  # Controls the initial speed of the adversarial car.\nparam OPT_ADV_DISTANCE = Range(0, 20)  # Specifies the distance at which the car begins its aggressive maneuver.\nparam OPT_ADV_THROTTLE = Range(0, 1) \nparam OPT_ADV_BREAK = Range(0, 1)  # Determines the intensity of the break.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait\n    do FollowLaneBehavior(globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetSteerAction(globalParameters.OPT_ADV_STEER)\n        wait 1  # Changes direction every second\n\nparam OPT_ADV_STEER = Range(-1, 1)  # Range for steering actions",
            "behavior WalkStraightBehavior(direction, speed):\n    while True:\n        take SetWalkingDirectionAction(direction)\n        take SetWalkingSpeedAction(speed)\n\nbehavior AdvBehavior():\n    while (distance to self) > 60:\n        wait\n    do WalkStraightBehavior(IntSpawnPt.heading + 180 deg, globalParameters.OPT_ADV_SPEED) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    take SetWalkingSpeedAction(0)\n\nparam OPT_ADV_DISTANCE = Range(0, 20)\nparam OPT_ADV_SPEED = Range(0, 5)",
            "behavior WalkStraightBehavior(direction, speed):\n    while True:\n        take SetWalkingDirectionAction(direction)\n        take SetWalkingSpeedAction(speed)\n\nbehavior AdvBehavior():\n    initialSpeed = globalParameters.OPT_INITIAL_SPEED\n    maxSpeed = globalParameters.OPT_MAX_SPEED\n    while (distance to self) > 60:\n        wait\n    while (distance to self) < globalParameters.OPT_ADV_DISTANCE:\n        currentSpeed = min(maxSpeed, initialSpeed + 0.1)  # Increase speed gradually\n        do WalkStraightBehavior(IntSpawnPt.heading + 180 deg, currentSpeed)\n        initialSpeed = currentSpeed\n\nparam OPT_INITIAL_SPEED = Range(0, 2)\nparam OPT_MAX_SPEED = Range(3, 5)\nparam OPT_ADV_DISTANCE = Range(0, 20)",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is close enough to be a threat.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance to self) < globalParameters.OPT_ADV_DISTANCE or (distance from self to EgoTrajectory) < globalParameters.OPT_STOP_DISTANCE\n    # Follow the planned trajectory at an increased speed, ignoring the red light and entering the intersection.\n    while (distance from self to EgoTrajectory) > globalParameters.OPT_STOP_DISTANCE:\n        take SetThrottleAction(globalParameters.OPT_THROTTLE)  # Increase throttle to accelerate.\n    while True:\n        take SetSpeedAction(0)  # Eventually comes to a stop or after the incident.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # Speed at which the adversarial vehicle crosses the intersection.\nparam OPT_ADV_DISTANCE = Range(0, 20)  # Distance threshold to start stopping.\nparam OPT_THROTTLE = Range(0.5, 1)  # Throttle level for acceleration.\nparam OPT_STOP_DISTANCE = Range(0, 2)  # Distance from ego's trajectory at which to stop the aggressive maneuver.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is within a threatening proximity.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_STEER_DISTANCE\n    # Once close to the ego's trajectory, the adversarial vehicle initiates a sharp turn.\n    while True:\n        take SetSpeedAction(self.speed)  # Continues moving at its current speed\n        take SetSteerAction(globalParameters.OPT_STEER)  # Makes an abrupt steering adjustment\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_STEER_DISTANCE = Range(0, 4)  # Distance from ego's trajectory at which the vehicle starts to turn.\nparam OPT_STEER = Range(0.5, 1.0)  # Defines the intensity of the steering action.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is within a threatening proximity.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_STEER_DISTANCE\n    # Once close to the ego's trajectory, the adversarial vehicle initiates a sharp turn.\n    while True:\n        take SetSpeedAction(self.speed)  # Continues moving at its current speed\n        take SetSteerAction(globalParameters.OPT_STEER)  # Makes an abrupt steering adjustment\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_STEER_DISTANCE = Range(0, 4)  # Distance from ego's trajectory at which the vehicle starts to turn.\nparam OPT_STEER = Range(-1.0, -0.5)  # Defines the intensity of the steering action.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is sufficiently close to pose a threat.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_BRAKE_DISTANCE\n    # Executes a sudden braking maneuver once it is within a critical distance of the ego's trajectory.\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)  # Initiates a hard brake to simulate abrupt stopping in the intersection.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_BRAKE_DISTANCE = Range(0, 4)  # The critical distance at which the adversarial begins to brake.\nparam OPT_BRAKE = Range(0, 1)  # The intensity of the braking action, ranging from a slight decrease in speed to a full stop.",
            "\nbehavior AdvBehavior():\n    while (distance to self) > 60:\n        wait\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance to self) < globalParameters.OPT_ADV_DISTANCE\n    while True:\n        take SetThrottleAction(globalParameters.OPT_THROTTLE)\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_ADV_DISTANCE = Range(5, 20)  # The critical distance at which the adversarial begins to accelerate.\nparam OPT_THROTTLE = Range(0.5, 1.0)  # The intensity of the accelerate action, ranging from a slight decrease in speed to a full stop.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is within a close enough range to impact the ego vehicle's path.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_STOP_DISTANCE\n    # Once in close proximity to the ego's trajectory, the adversarial vehicle cuts off the path and then stops.\n    while True:\n        take SetSpeedAction(0)  # The adversarial vehicle stops, completing the cut-off maneuver.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_STOP_DISTANCE = Range(0, 2)  # The proximity at which the adversarial vehicle will stop after cutting off the ego.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is within a significant range to impact the ego's maneuver.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_BRAKE_DISTANCE\n    # Once within a critical distance of the ego's trajectory, the adversarial vehicle initiates a sudden braking maneuver.\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)  # Continues to apply brakes to simulate an emergency or unexpected stop.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_BRAKE_DISTANCE = Range(0, 4)  # The critical distance at which the adversarial vehicle begins its sudden stop.\nparam OPT_BRAKE = Range(0, 1)  # The intensity of the braking action, potentially simulating an abrupt or gentle stop.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is close enough to affect the ego's maneuver.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_STEER_DISTANCE\n    # Initiates a sudden right turn as it gets close to the intersection.\n    while True:\n        take SetSpeedAction(self.speed)  # Maintains its current speed\n        take SetSteerAction(globalParameters.OPT_STEER)  # Executes a sharp turn\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_STEER_DISTANCE = Range(0, 4)  # The distance at which the adversarial vehicle starts its sudden maneuver.\nparam OPT_STEER = Range(0.5, 1.0)  # The intensity of the steering action, specifying the sharpness of the turn.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # Wait until the vehicle is close enough to influence the ego's path.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_ADV_DISTANCE\n    # Executes a left turn maneuver.\n    take SetSteerAction(globalParameters.OPT_STEER)  # Full left turn\n    while True:\n        take SetSpeedAction(0)  # Eventually stops after completing the turn\n\nparam OPT_ADV_SPEED = Range(5, 15)  # Speed at which the vehicle approaches the intersection.\nparam OPT_ADV_DISTANCE = Range(0, 5)  # The critical distance to start the turn.\nparam OPT_STEER = Range(-1.0, 0.0)",
            "behavior AdvBehavior():\n    lastTurnDirection = None  # Initialize with no previous turn direction.\n    \n    while (distance to self) > 60:\n        wait  # Wait until the vehicle is close enough to influence the ego's path.\n\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_TURN_DISTANCE\n    # Execute a turn based on the last turn direction.\n    if lastTurnDirection == \"left\":\n        take SetSteerAction(globalParameters.OPT_STEER_RIGHT)  # Turn right this time\n        lastTurnDirection = \"right\"\n    else:\n        take SetSteerAction(globalParameters.OPT_STEER_LEFT)  # Turn left this time\n        lastTurnDirection = \"left\"\n\n    while True:\n        take SetSpeedAction(self.speed)  # Continues moving in the new direction\n\nparam OPT_ADV_SPEED = Range(5, 15)\nparam OPT_TURN_DISTANCE = Range(0, 5)\nparam OPT_STEER_LEFT = Range(-1.0, 0.0)\nparam OPT_STEER_RIGHT = Range(0.0, 1.0)",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is close enough to influence the ego's maneuver.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_STEER_DISTANCE\n    # Initiates erratic steering maneuvers as it gets close to the intersection.\n    for steer in globalParameters.STEER_LIST:\n        take SetSpeedAction(self.speed), SetSteerAction(steer)  # Applies a series of steering adjustments.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches the intersection.\nparam OPT_STEER_DISTANCE = Range(0, 4)  # The critical distance at which the adversarial vehicle begins its erratic maneuver.\nparam STEER_LIST = [Range(-globalParameters.OPT_STEER, globalParameters.OPT_STEER) for i in range(1000)]  # List of random steering angles.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is within impactful range.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance from self to EgoTrajectory) < globalParameters.OPT_SLOW_DISTANCE\n    # Begins to drive extremely slowly to block the lanes once it is near enough to the intersection.\n    while True:\n        take SetSpeedAction(globalParameters.OPT_SLOW_SPEED)  # Maintains a very slow speed to disrupt traffic flow.\n\nparam OPT_SLOW_DISTANCE = Range(0, 4)  # The distance at which the adversarial vehicle starts slowing down.\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle initially approaches the intersection.\nparam OPT_SLOW_SPEED = Range(0, 2)  # The extremely slow speed that the adversarial vehicle adopts to block the lanes.",
            "behavior AdvBehavior():\n    speedCycle = [globalParameters.OPT_HIGH_SPEED, globalParameters.OPT_LOW_SPEED] * 10  # Predefined speed cycle\n    while (distance to self) > 60:\n        wait\n    for speed in speedCycle:\n        take SetSpeedAction(speed)\n        wait 2  # Changes speed every 2 seconds\n\nparam OPT_HIGH_SPEED = Range(10, 20)\nparam OPT_LOW_SPEED = Range(1, 5)",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial car waits until the ego vehicle is within a significant distance.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until ((distance to self) < globalParameters.OPT_ADV_DISTANCE and RelativePosition(ego, self).dot(self.velocity) < 0)\n    # The condition ensures that the reversal is triggered only when the ego is moving towards the adversarial vehicle, indicating proximity.\n    while True:\n        take SetReverseAction(True)  # Initiates the reversal.\n        take SetThrottleAction(globalParameters.OPT_THROTTLE)  # Applies throttle to increase the speed of the reversal.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle initially approaches.\nparam OPT_ADV_DISTANCE = Range(0, 25)  # The proximity within which the reversal is triggered.\nparam OPT_THROTTLE = Range(0.5, 1.0)  # The intensity of the throttle during the reversal.",
            "behavior AdvBehavior():\n    while (distance to self) > 60:\n        wait  # The adversarial vehicle waits until it is close enough to impact the ego's maneuver.\n    do FollowTrajectoryBehavior(globalParameters.OPT_ADV_SPEED, advTrajectory) until (distance to self) < globalParameters.OPT_ADV_DISTANCE or (distance from self to EgoTrajectory) < globalParameters.OPT_BRAKE_DISTANCE\n    # Accelerates towards the ego vehicle.\n    while (distance from self to EgoTrajectory) > globalParameters.OPT_BRAKE_DISTANCE:\n        take SetThrottleAction(globalParameters.OPT_THROTTLE)  # Applies throttle to increase speed.\n    # Once close enough, it decelerates abruptly.\n    while True:\n        take SetBrakeAction(globalParameters.OPT_BRAKE)  # Initiates a sudden brake to reduce speed sharply.\n\nparam OPT_ADV_SPEED = Range(5, 15)  # The speed at which the adversarial vehicle approaches.\nparam OPT_ADV_DISTANCE = Range(0, 25)  # The proximity within which the acceleration is triggered.\nparam OPT_THROTTLE = Range(0.5, 1.0)  # The intensity of the throttle during the acceleration.\nparam OPT_BRAKE = Range(0, 1)  # The intensity of the braking action.\nparam OPT_BRAKE_DISTANCE = Range(0, 4)  # The critical distance at which the adversarial vehicle begins its deceleration.",
            "behavior AdvBehavior():\n    laneChangeCompleted = False\n    try:\n        do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED)\n    interrupt when (distance from self to ego) < globalParameters.OPT_LANE_CHANGE_TRIGGER_DISTANCE and not laneChangeCompleted:\n        current_laneSection = network.laneSectionAt(self)\n        RightLaneSec = current_laneSection._laneToRight\n        do LaneChangeBehavior(\n            laneSectionToSwitch=RightLaneSec,\n            target_speed=globalParameters.OPT_ADV_SPEED)\n        laneChangeCompleted = True\n\nparam OPT_ADV_SPEED = Range(5, 25)  # Speed at which the adversarial vehicle travels before attempting the lane change.\nparam OPT_LANE_CHANGE_TRIGGER_DISTANCE = Range(0, 20)  # The distance from the ego vehicle at which the adversarial vehicle initiates the lane change.",
            "behavior AdvBehavior():\n    laneChangeCompleted = False\n    try:\n        do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED)\n    interrupt when (distance from self to ego) < globalParameters.OPT_LANE_CHANGE_TRIGGER_DISTANCE and not laneChangeCompleted:\n        current_laneSection = network.laneSectionAt(self)\n        LeftLaneSec = current_laneSection._laneToLeft\n        do LaneChangeBehavior(\n            laneSectionToSwitch=LeftLaneSec,\n            target_speed=globalParameters.OPT_ADV_SPEED)\n        laneChangeCompleted = True\n\nparam OPT_ADV_SPEED = Range(5, 25)  # Speed at which the adversarial vehicle travels before attempting the lane change.\nparam OPT_LANE_CHANGE_TRIGGER_DISTANCE = Range(0, 20)  # The distance from the ego vehicle at which the adversarial vehicle initiates the lane change.",
            "behavior AdvBehavior():\n    laneChangeCompleted = False\n    try:\n        do FollowLaneBehavior(target_speed=globalParameters.OPT_ADV_SPEED)\n    interrupt when (distance from self to ego) < globalParameters.OPT_LANE_CHANGE_TRIGGER_DISTANCE and network.laneAt(self) is not network.laneAt(ego) and not laneChangeCompleted:\n        LaneSec = network.laneSectionAt(ego)\n        do LaneChangeBehavior(\n            laneSectionToSwitch=LaneSec,\n            target_speed=globalParameters.OPT_ADV_SPEED)\n        laneChangeCompleted = True"
        ]
    },
    "geometry": {
        "description": [
            "The ego is driving on a straight road",
            "The ego vehicle navigates a right turn at an intersection, following a specific maneuver path.",
            "The ego vehicle navigates a right turn at an intersection, following a specific maneuver path.",
            "The ego vehicle navigates a left turn at a four-way intersection, following a specific maneuver path.",
            "The ego vehicle navigates a left turn at a three-way intersection, following a specific maneuver path.",
            "The ego vehicle navigates a right turn at a four-way intersection, following a specific maneuver path.",
            "The ego vehicle navigates a right turn at a three-way intersection, following a specific maneuver path.",
            "\nThe ego vehicle is positioned in a lane with a right lane moving in the same direction.",
            "The ego vehicle is placed in a lane that has a left lane moving in the same direction.",
            "The ego vehicle starts positioned between two lanes that both move in the same direction.",
            "The ego vehicle is positioned on a single-lane road with no adjacent lanes.",
            "The ego vehicle is positioned on a two-lane road with traffic flowing in opposite directions.",
            "The ego vehicle drives straight across a four-way signalized intersection, the light is red for adversarial agent.",
            "The ego vehicle drives straight across a four-way unsignalized intersection.",
            "The ego vehicle starts an unprotected left turn at an four-way intersection."
        ],
        "snippet": [
            "Town = 'Town05'\nlane = Uniform(*network.lanes)\nEgoTrajectory = lane.centerline\nEgoSpawnPt = OrientedPoint on lane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is4Way or i.is3Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is4Way or i.is3Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.RIGHT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is3Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.RIGHT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is3Way, network.intersections))\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.RIGHT_TURN, intersection.maneuvers))\negoInitLane = egoManeuver.startLane\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoInitLane.centerline\n\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL",
            "Town = 'Town03'\n# Identifying lane sections with a right lane moving in the same forward direction\nlaneSecsWithRightLane = []\nfor lane in network.lanes:\n    for laneSec in lane.sections:\n        if laneSec._laneToRight is not None and laneSec._laneToRight.isForward == laneSec.isForward:\n            laneSecsWithRightLane.append(laneSec)\n\n# Selecting a random lane section from identified sections for the ego vehicle\nEgoLaneSec = Uniform(*laneSecsWithRightLane)\nEgoSpawnPt = OrientedPoint in EgoLaneSec.centerline",
            "Town = 'Town03'\n# Identifying lane sections with a left lane moving in the same forward direction\nlaneSecsWithLeftLane = []\nfor lane in network.lanes:\n    for laneSec in lane.sections:\n        if laneSec._laneToLeft is not None and laneSec._laneToLeft.isForward == laneSec.isForward:\n            laneSecsWithLeftLane.append(laneSec)\n\n# Selecting a random lane section from identified sections for the ego vehicle\nEgoLaneSec = Uniform(*laneSecsWithLeftLane)\nEgoSpawnPt = OrientedPoint in EgoLaneSec.centerline",
            "Town = 'Town03'\n# Identifying lane sections with both left and right lanes moving in the same forward direction\nlaneSecsWithBothSides = []\nfor lane in network.lanes:\n    for laneSec in lane.sections:\n        if (laneSec._laneToLeft is not None and laneSec._laneToLeft.isForward == laneSec.isForward) and \n           (laneSec._laneToRight is not None and laneSec._laneToRight.isForward == laneSec.isForward):\n            laneSecsWithBothSides.append(laneSec)\n\n# Selecting a random lane section from identified sections for the ego vehicle\nEgoLaneSec = Uniform(*laneSecsWithBothSides)\nEgoSpawnPt = OrientedPoint in EgoLaneSec.centerline",
            "Town = 'Town03'\n# Identifying lane sections with no adjacent lanes\nlaneSecsWithNoAdjacent = []\nfor lane in network.lanes:\n    for laneSec in lane.sections:\n        if laneSec._laneToLeft is None and laneSec._laneToRight is None:\n            laneSecsWithNoAdjacent.append(laneSec)\n\n# Selecting a random lane section from identified sections for the ego vehicle\nEgoLaneSec = Uniform(*laneSecsWithNoAdjacent)\nEgoSpawnPt = OrientedPoint in EgoLaneSec.centerline",
            "Town = 'Town01'\n# Collecting lane sections that have a left lane (opposite traffic direction) and no right lane (single forward road)\nlaneSecsWithLeftLane = []\nfor lane in network.lanes:\n    for laneSec in lane.sections:\n        if laneSec._laneToLeft is not None and laneSec._laneToRight is None:\n            if laneSec._laneToLeft.isForward != laneSec.isForward:\n                laneSecsWithLeftLane.append(laneSec)\n\n# Selecting a random lane section that matches the criteria\nEgoLaneSec = Uniform(*laneSecsWithLeftLane)\nEgoSpawnPt = OrientedPoint in EgoLaneSec.centerline",
            "Town = 'Town05'\n\n## MONITORS\nmonitor TrafficLights:\n    freezeTrafficLights()\n    while True:\n        if withinDistanceToTrafficLight(ego, 100):\n            setClosestTrafficLightStatus(ego, \"green\")\n        if withinDistanceToTrafficLight(AdvAgent, 100):\n            setClosestTrafficLightStatus(AdvAgent, \"red\")\n        wait\n\nintersection = Uniform(*filter(lambda i: i.is4Way and i.isSignalized, network.intersections))\negoInitLane = Uniform(*intersection.incomingLanes)\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, egoInitLane.maneuvers))\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoManeuver.startLane.centerline\n\n# Setting up the ego vehicle at the initial position\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL\n\nrequire 10 <= (distance to intersection) <= 40",
            "Town = 'Town05'\nintersection = Uniform(*filter(lambda i: i.is4Way and not i.isSignalized, network.intersections))\negoInitLane = Uniform(*intersection.incomingLanes)\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, egoInitLane.maneuvers))\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoManeuver.startLane.centerline\n\n# Setting up the ego vehicle at the initial position\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL\n\nrequire 10 <= (distance to intersection) <= 40",
            "Town = 'Town05'\n\n## MONITORS\nmonitor TrafficLights:\n    freezeTrafficLights()\n    while True:\n        if withinDistanceToTrafficLight(ego, 100):\n            setClosestTrafficLightStatus(ego, \"green\")\n        if withinDistanceToTrafficLight(AdvAgent, 100):\n            setClosestTrafficLightStatus(AdvAgent, \"green\")\n        wait\n\nintersection = Uniform(*filter(lambda i: i.is4Way and i.isSignalized, network.intersections))\negoInitLane = Uniform(*intersection.incomingLanes)\negoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, egoInitLane.maneuvers))\nEgoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]\nEgoSpawnPt = OrientedPoint in egoManeuver.startLane.centerline\n\n# Setting up the ego vehicle at the initial position\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL\n\nrequire 10 <= (distance to intersection) <= 40"
        ]
    },
    "spawn": {
        "description": [
            "Adversarial agent spawns directly in front of the ego vehicle on the same straight road, heading in the same direction.",
            "Adversarial agent spawns directly in front of the ego vehicle on the same straight road, heading in the opposite direction.",
            "Adversarial agent spawns from the left front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from the right front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns directly behind the ego vehicle.",
            "Adversarial agent spawns diagonally left behind the ego vehicle for crossing.",
            "Adversarial agent spawns diagonally right behind the ego vehicle for crossing.",
            "Adversarial agent spawns from behind a bus stop on the right front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from behind a bus stop on the left front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from behind a vending machine on the right front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from behind a vending machine on the left front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from behind a parked car on the right front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns from behind a parked car on the left front of the ego vehicle on the same straight road for crossing.",
            "Adversarial agent spawns on the right front of the ego vehicle at the end of the ego's initial lane (i.e., on the front zebra crossing) for crossing.",
            "Adversarial agent spawns on the left front of the ego vehicle at the end of the ego's initial lane (i.e., on the front zebra crossing) for crossing.",
            "Adversarial agent spawns from the right side of the ego vehicle's end lane's start point  (i.e., zebra crossing on the side) for crossing.",
            "Adversarial agent spawns from the left side of the ego vehicle's end lane's start point  (i.e., zebra crossing on the side) for crossing.",
            "The adversarial agent spawns in the right front relative to the ego vehicle and drives straight.",
            "The adversarial agent spawns in the left front relative to the ego vehicle and drives straight.",
            "The adversarial agent spawns in the rear left relative to the ego vehicle and drives straight.",
            "The adversarial agent spawns in the rear right relative to the ego vehicle and drives straight.",
            "The adversarial agent spawns in the right front relative to the ego vehicle, which is driving forward. A slow-moving car is strategically placed in front of the ego vehicle to provoke a lane change attempt.",
            "The adversarial agent spawns in the left front relative to the ego vehicle, which is driving forward. A slow-moving car is strategically placed in front of the ego vehicle to provoke a lane change attempt to the left.",
            "Adversarial agent crosses the road from the right front with a parked car blocking the ego vehicle's lane.",
            "Adversarial agent crosses the road from the left front with a parked car blocking the ego vehicle's lane.",
            "Adversarial agent comes from the near opposite oncoming lane with a parked car blocking the ego vehicle's lane.",
            "The adversarial agent crosses from the right side of a four-way intersection and drives straight.",
            "The adversarial agent crosses from the left side of a four-way intersection  and drives straight.",
            "The adversarial agent crosses from the oncoming side of a four-way intersection and  drives straight.",
            "The adversarial agent crosses from the right side of a four-way intersection and turns left.",
            "The adversarial agent crosses from the left side of a four-way intersection and turns left.",
            "The adversarial agent crosses from the oncoming side of a four-way intersection and turns left.",
            "The adversarial agent crosses from the right side of a four-way intersection and turns right.",
            "The adversarial agent crosses from the left side of a four-way intersection and turns right.",
            "The adversarial agent crosses from the oncoming side of a four-way intersection and turns right."
        ],
        "snippet": [
            "param OPT_GEO_Y_DISTANCE = Range(10, 30)  # Frontal distance range\n\nFrontSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at FrontSpawnPt,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_Y_DISTANCE = Range(10, 30)  # Frontal distance range\n\nFrontSpawnPtOpp = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at FrontSpawnPtOpp,\n    with heading FrontSpawnPtOpp.heading + 180 deg,  # Opposite direction to the car\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(-8, -2)  # Negative range for left side\nparam OPT_GEO_Y_DISTANCE = Range(15, 50)\n\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} left of IntSpawnPt by globalParameters.OPT_GEO_X_DISTANCE,\n    with heading IntSpawnPt.heading - 90 deg,  # Heading perpendicular to the road, adjusted for left crossing\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_Y_DISTANCE = Range(15, 50)\n\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} right of IntSpawnPt by globalParameters.OPT_GEO_X_DISTANCE,\n    with heading IntSpawnPt.heading - 90 deg,  # Heading perpendicular to the road, adjusted for left crossing\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_Y_DISTANCE = Range(-30, -10)  # Negative range for behind the ego\n\nRearSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at RearSpawnPt,\n    with heading RearSpawnPt.heading,  # Same direction as the car, approaching from behind\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(-5, -2)  # Negative range for left side from behind\nparam OPT_GEO_Y_DISTANCE = Range(-25, -15)  # Diagonal rear left position\n\n# Define the spawn point of the adversarial agent relative to the ego vehicle position.\n# First, move directly in front of the ego and then adjust by the Y (forward/backward) and X (left/right) distances.\nDiagLeftRearSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nDiagLeftRearSpawnPt = OrientedPoint left of DiagLeftRearSpawnPt by globalParameters.OPT_GEO_X_DISTANCE\n\n# Setup adversarial agent's properties\nAdvAgent = {AdvObject} at DiagLeftRearSpawnPt,\n    with heading DiagLeftRearSpawnPt.heading,  # Assuming this heading should be aligned with the road if coming from behind\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(2, 5)  # Lateral distance to the right of the ego vehicle\nparam OPT_GEO_Y_DISTANCE = Range(-25, -15)  # Longitudinal distance behind the ego vehicle\n\n# Define the spawn point for the adversarial agent\nDiagRightRearSpawnPt = OrientedPoint right of EgoSpawnPt by globalParameters.OPT_GEO_X_DISTANCE,\n    following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\n\n# Setup the adversarial agent at the defined spawn point\nAdvAgent = {AdvObject} at DiagRightRearSpawnPt,\n    with heading DiagRightRearSpawnPt.heading - 180 deg,  # Heading opposite the road direction, for crossing from right rear\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = BusStop right of IntSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None\n    \nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(-8, -2)  # Negative range for left side\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nLeftFrontSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = BusStop left of LeftFrontSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading LeftFrontSpawnPt.heading,\n    with regionContainedIn None\n\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along LeftFrontSpawnPt.heading by SHIFT,\n    with heading LeftFrontSpawnPt.heading - 90 deg,  # Adjusted for sprinting out from the left\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nRightFrontSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = VendingMachine right of RightFrontSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading RightFrontSpawnPt.heading,\n    with regionContainedIn None\n\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along RightFrontSpawnPt.heading by SHIFT,\n    with heading RightFrontSpawnPt.heading + 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(-8, -2)  # Negative range for left side\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nLeftFrontSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = VendingMachine left of LeftFrontSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading LeftFrontSpawnPt.heading,\n    with regionContainedIn None\n\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along LeftFrontSpawnPt.heading by SHIFT,\n    with heading LeftFrontSpawnPt.heading - 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = Car right of IntSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None\n    \nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_BLOCKER_X_DISTANCE = Range(-8, -2)  # Negative range for left side\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(15, 50)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\nLeftFrontSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = Car left of LeftFrontSpawnPt by globalParameters.OPT_GEO_BLOCKER_X_DISTANCE,\n    with heading LeftFrontSpawnPt.heading,\n    with regionContainedIn None\n\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along LeftFrontSpawnPt.heading by SHIFT,\n    with heading LeftFrontSpawnPt.heading - 90 deg,  # Adjusted for spawning from the left\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_Y_DISTANCE = Range(-5, 5)\n\nIntSpawnPt = egoManeuver.startLane.centerline.end\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at IntSpawnPt offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(-8, -2)  # Adjusted for left side\nparam OPT_GEO_Y_DISTANCE = Range(-5, 5)\n\nIntSpawnPt = egoManeuver.startLane.centerline.end\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at IntSpawnPt offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading - 90 deg,  # Adjusted for coming from the left\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(2, 8)\nparam OPT_GEO_Y_DISTANCE = Range(-5, 5)\n\nIntSpawnPt = egoManeuver.endLane.centerline[0]  # Start of the end lane centerline\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at IntSpawnPt offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 90 deg,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "param OPT_GEO_X_DISTANCE = Range(-8, -2)  # Adjusted for left side\nparam OPT_GEO_Y_DISTANCE = Range(-5, 15)\n\nIntSpawnPt = egoManeuver.endLane.centerline[0]  # Start of the end lane centerline\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at IntSpawnPt offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading - 90 deg,  # Adjusted for coming from the left\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Identifying the adjacent lane for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(0, 30)\nadvLane = EgoLaneSec._laneToRight.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Identifying the adjacent lane for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(0, 30)\nadvLane = EgoLaneSec._laneToLeft.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Identifying the adjacent lane for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(-30, 0)\nadvLane = EgoLaneSec._laneToLeft.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Identifying the adjacent lane for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(-30, 0)\nadvLane = EgoLaneSec._laneToLeft.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Setup the leading vehicle's spawn point directly in front of the ego to simulate a slow-moving vehicle\nparam OPT_LEADING_DISTANCE = Range(0, 30)\nparam OPT_LEADING_SPEED = Range(1, 5)\nLeadingSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_LEADING_DISTANCE\nLeadingAgent = Car at LeadingSpawnPt,\n    with behavior FollowLaneBehavior(target_speed=globalParameters.OPT_LEADING_SPEED)\n\n# Identifying the adjacent lane for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(0, 30)\nadvLane = EgoLaneSec._laneToRight.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with heading advHeading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Setup the leading vehicle's spawn point directly in front of the ego to simulate a slow-moving vehicle\nparam OPT_LEADING_DISTANCE = Range(0, 30)\nparam OPT_LEADING_SPEED = Range(1, 5)\nLeadingSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_LEADING_DISTANCE\nLeadingAgent = Car at LeadingSpawnPt,\n    with behavior FollowLaneBehavior(target_speed=globalParameters.OPT_LEADING_SPEED)\n\n# Identifying the adjacent lane to the left for the Adversarial Agent and setting its spawn point further in front\nparam OPT_GEO_Y_DISTANCE = Range(0, 30)\nadvLane = EgoLaneSec._laneToLeft.lane\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE\nprojectPt = Vector(*advLane.centerline.project(IntSpawnPt.position).coords[0])\nadvHeading = advLane.orientation[projectPt]\n\n# Spawn the Adversarial Agent as a generic object placeholder {AdvObject}\nAdvAgent = {AdvObject} at projectPt,\n    with heading advHeading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Parameters for scenario elements\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(0, 40)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\n# Ego vehicle setup\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL\n\n# Setup for the blocking car that the ego must bypass\nlaneSec = EgoLaneSec\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = Car at IntSpawnPt,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None\n\n# Setup for the pedestrian who suddenly appears and complicates the maneuver\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 90 deg,  # Perpendicular to the road, crossing the street\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Parameters for scenario elements\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(0, 40)\nparam OPT_GEO_X_DISTANCE = Range(-2, 2)\nparam OPT_GEO_Y_DISTANCE = Range(2, 6)\n\n# Ego vehicle setup\nego = Car at EgoSpawnPt,\n    with regionContainedIn None,\n    with blueprint EGO_MODEL\n\n# Setup for the blocking car that the ego must bypass\nlaneSec = EgoLaneSec\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = Car at IntSpawnPt,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None\n\n# Setup for the pedestrian who suddenly appears and complicates the maneuver\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading - 90 deg,  # Perpendicular to the road, crossing the street\n    with regionContainedIn None,\n    with behavior AdvBehavior()",
            "# Parameters for scenario elements\nparam OPT_GEO_BLOCKER_Y_DISTANCE = Range(0, 40)\nparam OPT_GEO_X_DISTANCE = Range(-8, 0)  # Offset for the agent in the opposite lane\nparam OPT_GEO_Y_DISTANCE = Range(10, 30)\n\n# Setting up the parked car that blocks the ego's path\nlaneSec = EgoLaneSec  # Assuming EgoLaneSec is predefined in the geometry part\nIntSpawnPt = OrientedPoint following roadDirection from EgoSpawnPt for globalParameters.OPT_GEO_BLOCKER_Y_DISTANCE\nBlocker = Car at IntSpawnPt,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None\n\n# Setup for the motorcyclist who unexpectedly enters the scene\nSHIFT = globalParameters.OPT_GEO_X_DISTANCE @ globalParameters.OPT_GEO_Y_DISTANCE\nAdvAgent = {AdvObject} at Blocker offset along IntSpawnPt.heading by SHIFT,\n    with heading IntSpawnPt.heading + 180 deg,  # The agent is facing the opposite direction, indicating oncoming\n    with regionContainedIn laneSec._laneToLeft,  # Positioned in the left lane, assuming it's the oncoming traffic lane\n    with behavior AdvBehavior()",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.STRAIGHT, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 70 deg <= RelativeHeading(AdvAgent) <= 110 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.STRAIGHT, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire -110 deg <= RelativeHeading(AdvAgent) <= -70 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.STRAIGHT, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 160 deg <= abs(RelativeHeading(adversary)) <= 180 deg\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.LEFT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 70 deg <= RelativeHeading(AdvAgent) <= 110 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.LEFT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire -110 deg <= RelativeHeading(AdvAgent) <= -70 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.LEFT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 160 deg <= abs(RelativeHeading(adversary)) <= 180 deg\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.RIGHT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 70 deg <= RelativeHeading(AdvAgent) <= 110 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.RIGHT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire -110 deg <= RelativeHeading(AdvAgent) <= -70 deg  # Ensuring the agent approaches from an angle indicative of crossing\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])",
            "# Defining adversarial maneuvers as those conflicting with the ego's straight path\nadvManeuvers = filter(lambda i: i.type == ManeuverType.RIGHT_TURN, egoManeuver.conflictingManeuvers)\nadvManeuver = Uniform(*advManeuvers)\nadvTrajectory = [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]\nadvSpawnPt = advManeuver.connectingLane.centerline[0]  # Initial point on the connecting lane's centerline\nIntSpawnPt = advManeuver.connectingLane.centerline.start  # Start of the connecting lane centerline\n\nparam OPT_GEO_Y_DISTANCE = Range(-10, 10)\n# Setting up the adversarial agent\nAdvAgent = {AdvObject} following roadDirection from IntSpawnPt for globalParameters.OPT_GEO_Y_DISTANCE,\n    with heading IntSpawnPt.heading,\n    with regionContainedIn None,\n    with behavior AdvBehavior()\n\n# Requirements to ensure the adversarial agent's relative position and trajectory are correctly aligned with the scenario's needs\nrequire 160 deg <= abs(RelativeHeading(adversary)) <= 180 deg\nrequire any([AdvAgent.position in traj for traj in [advManeuver.startLane, advManeuver.connectingLane, advManeuver.endLane]])"
        ]
    }
}